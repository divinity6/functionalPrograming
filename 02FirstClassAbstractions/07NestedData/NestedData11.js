/**
 * 프로그람 설명문서 주석
 * 2022.06. 25
 *
 *
 *           ===== 정리 =====
 *
 *      - 앞에서 배운 고차함수를 정리
 *
 *      1. 배열을 반복할때 for 반복문 대신 사용하기
 *
 *      --> forEach() 와 map() , filter(), reduce()는 배열을 효과적으로 다루는 고차 함수
 *      --> 이 함수들을 조합해 복잡한 계산을 할 수 있다
 *
 *      2. 중첩된 데이터를 효율적으로 다루기
 *
 *      --> 깊이 중첩된 데이터를 변경하려면 바꾸려는 데이터, 내려가는 동안의 데이터를 모두 복사해야 함
 *      --> update() , nestedUpdate() 고차 함수로 중첩 단계에 상관없이 특정한 값을수술 하는 것처럼 바꾸기
 *
 *      3. 카피-온-라이트 원칙 적용하기
 *
 *      --> 카피-온-라이트 원칙을 적용한 코드는 중복이 많다
 *      --> 복사하고 바꾸고 리턴하는 코드가 항상 있다
 *      ----> withArrayCopy() , withObjectCopy() 를 사용하면 카피-온-라이트 맥락안에서
 *            어떤 동작이든 수행할 수 있다
 *
 *      4. try/catch 로깅 규칙을 코드화
 *
 *      --> wrapLogging()은 어떤 함수를 받아 그 함수가 리턴하는 값을 그대로 리턴해 주지만,
 *          에러가 발생하면 잡아서 로그를 남기는 함수
 *
 *      -->  wrapLogging()은 어떤 함수에 다른 행동이 추가된 함수로 바꿔주는 예제
 *
 *
 *
 *          ===== 요점 =====
 *
 *      - update()는 일반적인 패턴을 구현한 함수형 도구
 *        ( update() 를 사용하면 객체 안에서 값을 꺼내 변경하고 다시 설정하는 일을 수동으로 하지 않아도 된다 )
 *
 *      - nestedUpdated() 는 깊이 중첩된 데이터를 다루는 함수형 도구
 *        ( 바꾸려고 하는 값이 어디있는지, 가리키는 키 경로만 알면 중첩된 데이터를 쉽게 바꿀 수 있음 )
 *
 *      - 보통 일반적인 반복문은 재귀보다 명확하다
 *      --> 하지만 중첩된 데이터를 다룰때는 재귀가 더 쉽고 명확하다
 *
 *      - 재귀는 스스로 불렀던 곳이 어디인지 유지하기 위해 스택을 사용한다
 *      --> 재귀함수에서 스택은 중첩된 데이터 구조를 그대로 반영한다
 *
 *      - 깊이 중첩된 데이터는 이해하기 어렵다
 *      --> 깊이 중첩된 데이터를 다룰 때 모든 데이터 구조와 어떤 경로에 어떤 키가 있는지 기억해야 한다
 *
 *      - 많은 키를 가지고 있는 깊이 중첩된 구조에 추상화의 벽을 사용하면 알아야 할 것들이 줄어든다
 *      --> 추상화 벽으로 깊이 중첩된 데이터 구조를 쉽게 다룰 수 있다
 */
title( '깊이 중첩된 데이터에 추상화의 벽 사용' )
{

}
